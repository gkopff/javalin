/*
 * Javalin - https://javalin.io
 * Copyright 2017 David Ã…se
 * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE
 */
@file:JvmName("RouteOverviewUtil")

package io.javalin.core.util

import io.javalin.Handler
import io.javalin.Javalin
import io.javalin.core.HandlerType
import io.javalin.security.Role
import sun.reflect.ConstantPool

data class RouteOverviewEntry(val httpMethod: HandlerType, val path: String, val handler: Handler, val roles: List<Role>?)


fun createHtmlOverview(app: Javalin): String {
    return """
        <meta name='viewport' content='width=device-width, initial-scale=1'>
        <style>
            b, thead {
                font-weight:700
            }
            body {
                font-family:monospace;
                padding:15px
            }
            table {
                border-collapse:collapse;
                font-size:14px;
                border:1px solid #d5d5d5;
                width:100%;
                white-space:pre
            }
            thead {
                background:#e9e9e9;
                border-bottom:1px solid #d5d5d5
            }
            tbody tr:hover {
                background:#f5f5f5
            }
            td {
                padding:6px 15px
            }
            b {
                color:#33D
            }
        </style>
        <body>
            <h1>All mapped routes</h1>
            <table>
                <thead>
                    <tr>
                        <td>Method</td>
                        <td>Path</td>
                        <td>Handler</td>
                        <td>Roles</td>
                    </tr>
                </thead>
                ${app.routeOverviewEntries.map { (httpMethod, path, handler, roles) ->
        "<tr><td>$httpMethod</td><td>$path</td><td><b>${handler.metaInfo}</b></td><td>${roles?.toString()
                ?: "-"}</td></tr>"
    }.joinToString("")}
            </table>
        </body>
    """
}

private const val lambdaSign = "??? (anonymous lambda)"

private val Handler.parentClass: Class<*> get() = Class.forName(this.javaClass.name.takeWhile { it != '$' })
private val Handler.implementingClassName: String? get() = this.javaClass.name

private val Handler.isKotlinAnonymousLambda: Boolean get() = this.javaClass.enclosingMethod != null
private val Handler.isKotlinMethodReference: Boolean get() = this.javaClass.declaredFields.any { it.name == "function" }
private val Handler.isKotlinField: Boolean get() = this.javaClass.fields.any { it.name == "INSTANCE" }

private val Handler.isJavaAnonymousLambda: Boolean get() = this.javaClass.isSynthetic
private val Handler.isJavaMethodReference: Boolean get() = this.methodName != null
private val Handler.isJavaField: Boolean get() = this.fieldName != null

private fun Any.runMethod(name: String): Any = this.javaClass.getMethod(name).apply { isAccessible = true }.invoke(this)

val Handler.metaInfo: String
    get() {
        // this is just guesswork...
        return when {
            isKotlinMethodReference -> {
                val f = this.javaClass.getDeclaredField("function")
                        .apply { isAccessible = true }
                        .get(this)
                f.runMethod("getOwner").runMethod("getJClass").runMethod("getName").toString() + "::" + f.runMethod("getName")
            }
            isKotlinAnonymousLambda -> parentClass.name + "::" + lambdaSign
            isKotlinField -> parentClass.name + "." + fieldName

            isJavaMethodReference -> parentClass.name + "::" + methodName
            isJavaField -> parentClass.name + "." + fieldName
            isJavaAnonymousLambda -> parentClass.name + "::" + lambdaSign

            else -> implementingClassName + ".class"
        }
    }

val Handler.fieldName: String?
    get() = try {
        parentClass.declaredFields.find { it.isAccessible = true; it.get(it) == this }?.name
    } catch (ignored: Exception) { // Nothing really matters.
        null
    }

val Handler.methodName: String?
    get() {
        val constantPool = Class::class.java.getDeclaredMethod("getConstantPool").apply { isAccessible = true }.invoke(javaClass) as ConstantPool
        for (i in constantPool.size downTo 0) {
            try {
                val name = constantPool.getMemberRefInfoAt(i)[1];
                // Autogenerated ($), constructor, or kotlin's check (fix maybe?)
                if (name.contains("(\\$|<init>|checkParameterIsNotNull)".toRegex())) {
                    continue
                } else {
                    return name
                }
            } catch (ignored: Exception) {
            }
        }
        return null
    }
